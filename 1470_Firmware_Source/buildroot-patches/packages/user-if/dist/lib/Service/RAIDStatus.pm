#!/usr/bin/env perl
# Class   : Service::Storage.pm
# Purpose : Access for storage stats. 
# Author  : R crewe
#

use strict;
use nasCommon;

# This object is the Status returned as a result of examining the RAID 
# status on all the RAID drives.
package Service::RAIDStatus;
    # private contructor
#    my $new = sub {
    sub new {
        my $class = shift;
        my $this = {};
        bless $this, $class;
        
        $this->{fault} = shift;
        $this->{severity} = shift;
        
        return $this;
    };
    
    # will change the status code to the new code, only if the new code is
    # more severe/important.
    sub upgradeStatus {
        my $this = shift;
        my $replacement = shift;
        
        # if the replacement is a more important error then
        # start using it
        if ($this->{severity} <= $replacement->{severity} ) {
            $this->{fault} = $replacement->{fault};
            $this->{severity} = $replacement->{severity};
        }
        return $this;
    }
    
    # Converts an RAIDStatus into a text message. The message is not stored
    # with the error code as the language may change during execution.
    sub toMessage {
        my $this = shift;
        my $config = shift;
        
        my $ecode = {
            'unknown'	=> 'm20005',
            'ok'		=> 'm20005',
            'ok_sync'	=> 'm20007',
            'newdrive_a'=> 'm20010',
            'newdrive_b'=> 'm20011',
            'faulty'	=> 'm20003',
            'faulty_a'	=> 'm20001',
            'faulty_b'	=> 'm20002'
        }->{$this->{fault}} || 'f0000';
        return nasCommon::getMessage($config, $ecode );        
    }
    
    # overload the main comparison operators so that other comparison operators
    # may be autogenerated
    use overload 
        cmp => sub {
            my $this = shift;
            my $other = shift;
            return $this->{fault} cmp $other->{fault};
        },
        q(<=>) => sub {
            my $this = shift;
            my $other = shift;
            return $this->{fault} cmp $other->{fault};
        };

    # some predefined statussesses
    sub UNKNOWN         { return Service::RAIDStatus->new( 'unknown'    , 0); }
    sub OK              { return Service::RAIDStatus->new( 'ok'         , 1); }
    sub SYNCHRONISING   { return Service::RAIDStatus->new( 'ok_sync'    , 2); }
    sub NEWDRIVEA       { return Service::RAIDStatus->new( 'newdrive_a' , 3); }
    sub NEWDRIVEB       { return Service::RAIDStatus->new( 'newdrive_b' , 3); }
    sub FAULTY          { return Service::RAIDStatus->new( 'faulty'     , 4); }
    sub FAULTYA         { return Service::RAIDStatus->new( 'faulty_a'   , 5); }
    sub FAULTYB         { return Service::RAIDStatus->new( 'faulty_b'   , 5); }
1;
